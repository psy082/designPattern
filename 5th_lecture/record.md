Interface

여러 언어에서 공통적으로 정의된 일반적인 명사가 아니다
각 언어마다의 의미가 다르다.

js에서는
어떤 key의 어떤 함수가 저장되어 있는데, 해당 함수의 인자와 return 값의 형식이 동일하다

정적 언어에서는 타입 처럼 정의하기도 한다.
언어마다 정의되는 범위가 다르다.
언어에서도 버전마다 달라질 수 있다.
function(arguments): returnType --> 객체의 method는 this context가 포함된다.
(java 에서는 signature에 returnType이 포함되지 않는다.)

interfaceA => m1 | m2 | m3 | m4 반드시 가지고 있는 정의가 interfaceA
더 이상 함수 하나하나의 signature의 일치를 보지 않고, interface 단위로 어떤 객체가 interface를 따르는지 여부를 확인한다.
함수 signature set를 가지고 있는지 여부를 파악한다.

어떤 class를 만들 때, class에 method를 random 하게 만들었다 해도 interface를 만족하도록 method들이 구성되어 있다고 한다면,

하나의 class에 여러개의 method가 들어있는데
하나의 객체에 여러 인터페이스가 구현되어 있을 수도 있다.

명시적으로 공유된 inerface를 외부에 공개하고 싶다 ==> 상속으로 표현한다.
interface B의 계약 조건을 지키기로 약속을 했기 때문에

Decorator

데코레이터는 꾸며주기 위해서
꾸미는 게 가능하려면? -> 본체가 사라지지 않고 본체의 context가 유지되어야 한다.
데코레이터를 구현하면 일반적으로 UNDO를 구현할 수 있다.
데코레이팅 하는 대상이 UNDO,REDO가 가능한지를 먼저 생각해보면 데코레이터 대상인지 파악할 수 있다.
이를 보면 데코레이터 패턴이 커맨드 패턴과 깊은 관련이 있는 걸 알 수 있다.

즉, 일종의 recursive 재귀함수를 구현하는 것이다.(컴포지트 패턴과 유사하다.)
런타임에 inject 조립 순서대로 마음대로 바꿀 수 있다 => 데코레이터 패턴을 사용하는 이유

컴포지트 패턴은 폴더 안에 파일과 폴더가 박혀있고 그 구조가 런타임에 바뀌는 것이 아니라
폴더와 파일을 처리하는 로직이 런타임에 바뀐다.

데코레이터 패턴은 전략 패턴과 좀 다르다.

외부 객체를 가져온 다는 점은 동일하지만
공통된 인터페이스를 사용하는 객체들 끼리 링크드 리스트로 연결되어 있고 리스트를 순회하면서 동작한다는 것이 다르다.

기능 한판으로 제공하는 전략패턴과는 다르게 기능을 잘게 나누어서 조금씩 추가하도록 구현할 수 있다.
수정도 조금씩 할 수 있다. 본체 위에 꾸미고 빼내고를 할 수 있는 패턴

dom에서는 데코레이터를 쓸지 말지를 어떻게 결정했을까? 기껏해야 뱉어낼 값이 문자열 값이라는 걸 알았기 때문에
그런데 문제가 발생: 문자열은 값이다. -> 왜 문제인가? 데코레이터의 대상이 되는 객체가 값을 따르는 경우에는 객체 컨텐스트를 사용할 수 없게 된다.
그래서 우회 방법을 쓸 수밖에 없게된다.

만약에 데코레이터 패턴이 값을 넘겨주지 않으려면 task 뿐만 아니라 li를 넘겨주어야 한다
-> 데코레이팅을 하면서 문자열 replace가 아니라 appendChild를 할 수 있다. 그래야 객체의 여러가지 컨텍스트를 사용할 수 있다.
문자열을 넘겨주고 있기 때문에 innerHTML로 생성하는 건 dom system이 해주는 것이지 우리가 객체 컨텍스트에 관여한 것이 아니다.

지금까지는 tag 문자열을 주면 화면을 잘 그리는 것처럼 보인다.
그러면 delete 같은 건 어떻게 구현할까? 문자열을 제거하면 되는가?

객체 컨텍스트를 까먹고 값만 가지고 있기 때문에 객체 바인딩과 관련된 문제가 발생한다.
-> 이 난점을 우회에서 해결하는 방법: Observer
