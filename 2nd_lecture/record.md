Design Pattern

생성패턴
구조패턴
행동패턴
-> 이미 객체지향설계에 숙달한 사람을 대상으로 함

객체지향설계를 학습할 수 있는 분류
다형성 
캡슐화
변화율
객체관계
역할모델 - 격리를 통한 역할모델의 구현

역할 모델을 기준으로 어떤 역할을 분리하기 위해 어떤 패턴을 사용하는지

알고리즘이 변화하는 이유?

비지니스 변화
연관 라이브러리 변화
호스트측 변화

-> 대부분 개발자 통제 밖에 있는 요소들

기존 제어문 기반의 알고리즘이 갖는 문제

"수정하면 전체가 컴파일 됨"
코드를 건드리는 행위 자체가 위험해 진다.
-> 코드를 격리해서 건드리는 범위를 줄여나가야 한다.
-> 알고리즘이 변화한 부분만 수정하고 나머지는 건드리고 싶지 않다.
최대한 개별 알고리즘을 함수로 분리 한다.

최대 이슈
필요해서 존재하는 분기문들 -> 제거할 수 없다.
그러나 제거할 수 없는 if 문을 어떻게 제거할 것인가?
분기 문 내부가 하드코딩 되어 있다면 손댈수가 없다.
어떻게 분기문을 분리할 것인가?

시도 1. case와 case에 대한 처리를 분리하기.
문제1: 경우가 변경될 때
- 대부분의 경우 side effect가 존재한다. 의존성이 있는 상태에서 코드만 분리되기 때문에 경우가 변경되었을 때, 모든 경우에 대해서 테스트가 필요하다.
문제2: 함수간 공통 부분
- 경우들끼리 공통 부분이 있어서 공통 부분을 빼내는 경우가 있다. 결국 프로시져 지향적으로 분리할 경우 공통 의존 데이터 문제가 남아있다.
- common을 사용하는 사용처가 많아질 수록, common을 고치기가 어려워진다.
- 상태에 대한 의존성이 점점 더 강해진다 -> 데이터를 공유하는 것 자체가 문제이다.
아예 원천적으로 데이터를 공유하지 못하도록 만드는 것이 목표. 데이터의 의존성이 강해지는 것을 사람의 머리로 이해하기 어렵다.
따라서 프로시져 지향 프로그래밍은 코드를 이해하기가 어렵다.

알고리즘 분화 시 객체지향에서 선택할 수 있는 두 가지 방법
1. 상속위임 - 내부 계약 관계로 추상층에서 공통 요소를 해결하고 상태를 공유할 수 있음.
확장된 쪽인 부모 쪽을 아는 것. 부모가 가지고 있는 모든 정보를 알고 있다.
객체 간 내부 사정을 알기 때문에 별도의 통신망이 필요하지는 않다.

2. 소유위임 - 외부 계약 관계로 각각이 독립적인 문제를 해결하며 메세지를 주고 받는 것으로 문제를 해결함.
소유위임 시 무조건 분리된 객체끼리 통신하는 통신망을 설정해야 한다. 독립된 객체 간의 통신망을 만들어야 한다.
GoF DP의 방향성 -> common과 case 사이의 여러가지 프로토콜을 정해야 한다.
그 사이에 통신해야 하는 층을 만들어야 하기 때문에 부수적인 코드가 생성된다.
우리가 통신해야 하는 대상의 종류가 다양할수록 소유위임이 유리해진다. 
더 많은 경우의 수를 처리할 수 있는 범용적인 솔루션으로서의 패턴을 제안하는 것이다. 
수많은 플러그인을 담을 수 있는 cms 시스템을 만들것인지?

어떤 경우에 상속을 하고 어떤 경우에 소유를 할 지는 상황에 따라서 달라진다.
소유와 상속을 사용하는 이유는 case를 대응하기 위해서 + case에 대한 처리를 확장하기 위해서
처리 속도가 낮아지고, 부하가 높아질 수도 있다.

메모리와 연산은 서로 교환 가능하다.
js의 prototype chain의 경우에도, 4mb라는 한계 속에서 객체지향을 지원하기 위해서
생성된 인스턴스를 참조값 체이닝으로 재사용하는 방식으로 메모리 사용을 최소화 해서 기능을 제공했다.
대신 속도가 저하된다. -> v8 엔진이 빨라진 이유는 프로토타입 체이닝을 전부 hashtable로 옮겼기 때문.

디자인 패턴이 고려되던 시기에는 메모리가 제한적인 시기 였기 때문에
대부분의 패턴들은 연산을 믾이 하고 메모리를 적게 쓰는 방향으로 고안되었다.
따라서 속도나, 성능이 중요한 이슈인 게임 업계에서는 디자인 패턴의 사용을 지양한다.
심지어 디자인 패턴의 사용으로 성능이 저하된 경우 설계가 잘못된 것이 아니기 때문에, 성능 저하의 원인을 찾기도 어렵다.

상태에 대한 분기는 사라지지 않는다.
"그 분기가 필요해서 태어났기 때문이다."
-> 정의 시점에 제거하는 방법은?

1. 분기 수 만큼 객체를 만들고
2. 실행시점에 경우의 수를 공급
하도록 밑의 layer에게 일을 미뤄버리면 된다.

기본적인 철학: 나는 내가 할 만큼만 하고, 나중에 나 혹은 나의 팀원들에게 일을 넘겨버린다.
어떻게 하면 일을 밑으로 미뤄버릴 수 있을까?가 핵심적인 사고 방식
내가 짠 건 어떻게 해야 앞으로도 변하지 않게 짤 것인가?
내가 짠 부분을 견고하게 짜고 나머지 부분은 미뤄버리기

살행시점으로 분기를 옮길 때의 장단점

장점

1. 정의 시점에 모든 경우를 몰라도 됨
2. 정의 시점에 그 경우를 처리하는 방법도 몰라도 됨

일정한 통제 범위 내에서 확장 가능한 알고리즘 설계 가능

재빨리 프로토 타입 등장, 바로 코드가 나오고, 코드에 기능이 추가되면서 안정적으로 추가된다.
agile하고도 잘 들어 맞는다.

단점

1. 실행 시점에 모든 경우를 반드시 기술해야 함       
    - 라우터 테이블을 이용했다.
    - 만약에 라우터 테이블에 빼먹고 기술하지 않은 케이스가 존재한다면, runtime error 혹은 context error에 빠지게 된다.
        -> 안정성이 떨어지게 된다. runtime에 설정을 빼먹었기 때문에 프로그램이 죽는 것. 
        -> 그렇게 되면 프로그램이 코드 상의 안정성을 잃어버리고 runtime에 어떤 설정 값을 넣는가에 따라서 프로그램의 성공과 실패가 결정되게 된다.
        -> 원래 정적인 코드에서 분기가 이루어 졌을 때는, 코드가 확정되었다면, 코드의 안정성이 보장되었었다.
        -> 그러나 코드가 멀쩡해도 runtime에 add 혹은 table 값을 누락한 것으로도 프로그램이 실패하게 된다.
        -> 프로그램의 안정성이 약해졌다. 호스트 코드에서 깨진다.
        -> 따라서 double check가 필요하게 된다. 
        -> e.g) Spring MVC로 웹사이트를 만든 경우, 모든 라우팅에 해당하는 것에 대한 검사는 외부에서 런타임에 검사할 수 밖에 없다.
    
2. 실행 시점마다 알고리즘의 안정성을 담보해야 함
    -> 전체 프로그램의 실패가 프로그램의 안정성과는 동떨어진 상태에서 일어난다.
    -> 수정의 구간은 작아졌지만, 실행 시점에서의 실패 범위는 더 늘어났다. 
    -> 런타임의 불안정성이 늘어났다.


매 호스트 코드마다 안정성을 따로 담보해야 함

위의 단점들을 보완하는 추가적인 패턴들 
-> 런타임 안정성이 보장되지 않기 때문에, 런타임에 객체를 짜지 말고, 런타임에 짜야 할 코드들을 묶어서 객체로 관리를 하겠다는 전략 
-> 런타임에 설정해야 하는 것들에 대해서 불안한 부분들을 코드화 시켜서 안정성을 높인다.
-> 패턴이 불완전하기 때문에 다른 패턴을 사용해서 단점을 보완하지 않으면, 약점이 커지고 불안정해진다.
-> 패턴이 패턴을 부른다. 패턴 간의 상호 작용과 컨텍스트를 이해하지 못하면, 패턴을 많이 사용해도 프로그램이 안정되지 않는다.
-> 어떤 패턴을 쓸 때, 어떤 패턴을 카운터로 사용해서 안정성을 높일 것인지를 이해해야 한다.
-> 캡술화 패턴: Factory, Facade, Builder Pattern

그래서 장단점이 명확하게 존재한다.
따라서 확장성이 떨어지고 안정성을 심각하게 담보해야 하는 고 안정성 고 가용성 프로그램의 경우에는 
이런 방식으로 설계하면 안된다.

런타임의 자유는 정적타임의 불안정성을 말하는 것과 마찬가지이다. -> trade-off가 존재한다.

좋은 개발자는 trade-off를 파악해서 균형을 잡는 것이다. ballance를 잡을 수 있는 눈.