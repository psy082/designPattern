Design Pattern

생성패턴
구조패턴
행동패턴
-> 이미 객체지향설계에 숙달한 사람을 대상으로 함

객체지향설계를 학습할 수 있는 분류
다형성 
캡슐화
변화율
객체관계
역할모델 - 격리를 통한 역할모델의 구현

역할 모델을 기준으로 어떤 역할을 분리하기 위해 어떤 패턴을 사용하는지

알고리즘이 변화하는 이유?

비지니스 변화
연관 라이브러리 변화
호스트측 변화

-> 대부분 개발자 통제 밖에 있는 요소들

기존 제어문 기반의 알고리즘이 갖는 문제

"수정하면 전체가 컴파일 됨"
코드를 건드리는 행위 자체가 위험해 진다.
-> 코드를 격리해서 건드리는 범위를 줄여나가야 한다.
-> 알고리즘이 변화한 부분만 수정하고 나머지는 건드리고 싶지 않다.
최대한 개별 알고리즘을 함수로 분리 한다.

최대 이슈
필요해서 존재하는 분기문들 -> 제거할 수 없다.
그러나 제거할 수 없는 if 문을 어떻게 제거할 것인가?
분기 문 내부가 하드코딩 되어 있다면 손댈수가 없다.
어떻게 분기문을 분리할 것인가?

시도 1. case와 case에 대한 처리를 분리하기.
문제1: 경우가 변경될 때
- 대부분의 경우 side effect가 존재한다. 의존성이 있는 상태에서 코드만 분리되기 때문에 경우가 변경되었을 때, 모든 경우에 대해서 테스트가 필요하다.
문제2: 함수간 공통 부분
- 경우들끼리 공통 부분이 있어서 공통 부분을 빼내는 경우가 있다. 결국 프로시져 지향적으로 분리할 경우 공통 의존 데이터 문제가 남아있다.
- common을 사용하는 사용처가 많아질 수록, common을 고치기가 어려워진다.
- 상태에 대한 의존성이 점점 더 강해진다 -> 데이터를 공유하는 것 자체가 문제이다.
아예 원천적으로 데이터를 공유하지 못하도록 만드는 것이 목표. 데이터의 의존성이 강해지는 것을 사람의 머리로 이해하기 어렵다.
따라서 프로시져 지향 프로그래밍은 코드를 이해하기가 어렵다.

알고리즘 분화 시 객체지향에서 선택할 수 있는 두 가지 방법
1. 상속위임 - 내부 계약 관계로 추상층에서 공통 요소를 해결하고 상태를 공유할 수 있음.
확장된 쪽인 부모 쪽을 아는 것. 부모가 가지고 있는 모든 정보를 알고 있다.
객체 간 내부 사정을 알기 때문에 별도의 통신망이 필요하지는 않다.

2. 소유위임 - 외부 계약 관계로 각각이 독립적인 문제를 해결하며 메세지를 주고 받는 것으로 문제를 해결함.
소유위임 시 무조건 분리된 객체끼리 통신하는 통신망을 설정해야 한다. 독립된 객체 간의 통신망을 만들어야 한다.
GoF DP의 방향성 -> common과 case 사이의 여러가지 프로토콜을 정해야 한다.
그 사이에 통신해야 하는 층을 만들어야 하기 때문에 부수적인 코드가 생성된다.
우리가 통신해야 하는 대상의 종류가 다양할수록 소유위임이 유리해진다. 
더 많은 경우의 수를 처리할 수 있는 범용적인 솔루션으로서의 패턴을 제안하는 것이다. 
수많은 플러그인을 담을 수 있는 cms 시스템을 만들것인지?

어떤 경우에 상속을 하고 어떤 경우에 소유를 할 지는 상황에 따라서 달라진다.
소유와 상속을 사용하는 이유는 case를 대응하기 위해서 + case에 대한 처리를 확장하기 위해서
처리 속도가 낮아지고, 부하가 높아질 수도 있다.




