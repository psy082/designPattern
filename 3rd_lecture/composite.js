/**
 * 모델링을 만들 때, 기획서, 혹은 디자인을 보고
 * 어떤 모델에 어떤 데이터, 어떤 메소드가 필요한지를 파악이 가능해야 한다.
 *
 * 개발 todo 항목이 entity라는 건 어떻게 알 수 있는가?
 * todo 자체가 상태 값을 가진다. todo text와 check여부에 대한 상태 값이 있다.
 *
 * 의존성이 낮은 것일 수록 수정이 덜 필요하다.
 * 가장 쉬운 순서대로 작성할 것.
 * 가장 생각할 필요가 없는 것부터 만들기. -> 좋은 프로그램은 가장 쉬운 것부터 처리할 때 만들어진다.
 */
const list1 = new Task("비사이드");
list1.add("지라설치");
list1.add("지라클라우드접속");

const list2 = new Task("s3-4");
list2.add("2강 답안 작성");
list2.add("3강 교안 작성");

// 요구사항이 생기면, 이게 정말 수정사항인지 확인할 필요가 있다.
const { list } = list2.byDate();
list[1].task.add("코드정리");
list[1].task.add("다이어그램정리");

// TaskList 무엇인 지 한국말로 정리해보자
// title을 가지고 있으면서 Task를 가지고 있는 것
// 단지 isComplete을 값을 가질 수 없다.

// Task 정의
// Title을 가지고 있으면서 Sub Task를 가지고 있는 것

// 결국 TaskList는 Task로 봐도 무방하다
// UI 상 표현이 Check를 못하게 했을 뿐이지
// Root 라는 폴더 하위의 Task로 볼 수 있다.

// 해당 Task를 표현할 때, 각각의 UI 표현을 다르게 할 수는 있다.
// 즉 Task 데이터 구조가 동일하고, 단지 UI 표현이 다르다.

// 그리고 사실 TaskList도 isComplete이 있다.
// 단지 isComplete의 정의를 자기 자신이 complete 된 것으로 볼 것인지
// 아니면 자식들이 전부 isComplete 된 것으로 볼 것인지의 차이
// 어떤 정책을 쓸 것인가의 차이가 있을 뿐
// 동일한 구조를 가지고 있다.

// 역할 인식은 기능에 따라서 분화하거나 상세화되는 것뿐만 아니라
// 중복을 제거하는 것이다.
// 중복을 제거하려면 역할이 같은 지를 판단해야 하는데,
// 이 때 View에 현혹되면 안된다. 모양이 같거나 다른지가 아니라 데이터 형태가 같은 지가 중요하다.
// View 떄문에 Model을 혼돈하면 안된다.
// Data 기준으로 View를 결정해야 한다.

// 객체 구조에 대한 분석이 이루어 지지 않는다면 디자인 패턴을 알아도 쓸모가 없어진다.

// 이전에는 Task인지 list인지에 대한 분기가 필요했지만
// 호스트 코드에서 사용할 때 필요한 지식이 줄어들었다.
// 역할 판정 및 병합은 중앙에서 통제 해야 한다.
