const TaskList = class {
    constructor(title) {
        if(!title) throw 'Invalid Title';
        this._title = title;
        this._list = [];
    }
    // factory를 통한 외부 공개를 통해서면 생성자에 대해 추상화 층을 확보할 수 있다.
    // 따라서 특별한 사유가 없다면 생성자가 아닌 factory를 통해 외부에 공개하는 것이 더 좋다.
    // 오염이 전파되지 않도록
    // 대부분 문제를 일으키는 원인은, "이 클래스는 앞으로 변경이 일어나지 않는 base 클래스다"라는 생각이다.

    // add method의 경우 값을 받아서 어떤 행동을 하려고 한다. 심지어 Task의 get도 값을 받아서 어떤 행동을 하려고 한다.
    // 이 메소드들은 이미 객체 컨텍스트를 어기고 있다. 복사되는 값을 이용해서 행동을 하기 때문에
    // 따라서 객체 지향에서는 객체 컨텍스트를 어기는 부분을 최소화 해서 entry라고 부르는 입구에서만 사용해야 하고
    // 다른 부분에서는 객체들을 사용해서 통신해야 한다. Task.get은 생성하는 역할을 하기 때문에 entry가 맞다. -> 값을 받아서 생성한 Task 인스턴스의 주소값을 반환하고 있다.
    // 값을 받은 뒤에 객체 컨텍스트로 변경해주는 경우에는 메소드가 값을 받아도 된다. 값이 계속 유지되면 안된다.
    // add도 값을 넣는 부분이기 때문에 값을 직접 받는다.
    // 그러나 remove는 처리하는 부분이기 때문에 값을 받으면 안된다. 예를 들어 title을 받으면 안된다. 반드시 객체의 주소가 들어와야 한다.
    // 나쁜 경우에는 title이 중복되는 Task들이 존재하는 경우 중복되는 Task 전부가 삭제되게 된다.
    // 객체 지향에서 값이 유지되는 유일한 공간은 객체의 field 공간이다.(객체의 상태 값)
    add(title, date) {this._list.push(Task.get(title, date));}
    // 값 컨텍스트를 사용하는 메소드를 사용할 경우에는 명시적으로 이름이 붙어야 한다.
    // 만약 title을 기준으로 Task를 삭제하는 method로 만들고 싶다면 method 이름이 removeByTitle이 되어야 한다.
    remove(task) {
        const list = this._list;
        if(list.includes(task)) list.splice(list.indexOf(task), 1);
    }
    // 편의 method를 제공하고 있다.
    // 하나의 상태값(stateGroup)이 더 있다. 보통 Todo에서는 완료된 항목들과 완료되지 않은 항목들로 나눠서 sort가 제공되기 때문에
    // 2단 정렬을 제공하기 위헤서 상태값이 하나가 더 필요하다.
    // Sort class에 있는 title과 date를 빌려왔다. TaskList는 Sort에 대한 지식이 있다.
    // 동시에 Task가 Sort를 상속하고 있기 때문에, Sort가 Task를 이용할 수 있는 권한이 생긴다.
    // 외부에 공개되지 않는 메소드는 내부에서 수정이 동시에 일어나면 되기 때문에, 매개변수의 개수가 많아도 괜찮다.(의존성 전파가 일어나지 때문에)

    // 인자를 없앨 때마다 method의 개수가 늘어난다. 인자의 개수를 늘리는 것이 더 나은가 아니면 method의 개수를 늘리는 것이 더 나은가?
    // method 개수가 늘어나는 편이 더 낫다. 인자가 하나가 되거나 없어질 때까지는 메소드 개수를 늘리는 것이 더 좋은 정책이다.
    // true/false 라는 isComplete에 대한 값이 들어갔다. 그런데 그 값 하나로 _getList의 반환 로직 일체가 일어난다.
    // 따라서 method가 객체가 아닌 값을 받을 때는 굉장히 조심해야 한다. 위임이 아니라 직접 조작이기 때문에.
    byTitle(stateGroup = true) {return this._getList(Sort.title, stateGroup);}
    byDate(stateGroup = true) {return this._getList(Sort.date, stateGroup);}
    _getList(sort, stateGroup) {
        const list = this._list;
        return !stateGroup ? [...list].sort(sort) : [
            ...list.filter(v=>!v.isComplete()).sort(sort),
            ...list.filter(v=>v.isComplete()).sort(sort)
        ];
    }
}

// 객체 지향과 함수 지향의 가장 큰 차이점은 함수를 사용하는지 여부가 아니다. 객체 지향도 함수를 사용한다.
// 가장 큰 차이는 함수형에서는 값이라는 컨텍스트를 사용한다. 인자가 넘어가면 항상 사본이 넘어간다.
// 인자를 전달 할 때, 값을 전달하지 않고, 참조를 전달하면 함수를 사용해도 함수형이 아니다.
// 전달되는 것들이 계속 복사되서, 기존 것에 대한 참조가 없는 상태로 전달되는 것이 함수형의 가장 큰 특징이다.

// 값의 내용 그 자체로 비교가 가능한 것이 값 컨텍스트 계속 사본이 넘어가기 때문에
// 메모리의 주소 값으로 비교하지 않는다. a, b가 저장된 메모리 주소가 달라도 비교한 값이 같을 수 있게 된다.
// 값의 모양이나 크기를 가지고 비교.

// 객체 컨텍스트에서는 서로 다른 a, b에 대한 비교를 메모리 주소값의 비교를 통해 한다.
// 객체 지향에서는 객체 컨텍스트를 사용해야지 객체지향이 되고
// 함수 지향에서는 값 컨텍스트를 사용해야지 함수지향이 된다.
// 따라서 이런 기본적인 전제들을 어기면, 각 개발이 지향하는 바가 깨지게 된다.

// 함수형에서는 모든 것이 값으로 식별하기 때문에 객체가 무의미 하다. 
// 만약에 메모리 주소를 사용해야 하는 경우가 생긴다면, 
// 인자의 값, 지역 변수의 일부, 내부에서 해소되어서 더 이상 변경이 일어나지 않는 객체의 경우에만 사용할 수 있다.
// 값을 사용하지 않는다면 순수함수가 될 수 없다.